def gen_Send_Message(name):
    print('''
void {name}_Send_Message({name}_Event_Wrapper e) {
    bool success;
    system_message_t *msg;
    {name}_Event_Wrapper *wrapper;

    // The event wrapper is passed in on the stack, so we have to
    // allocate some memory that we can put in the message queue.
    msg = malloc(sizeof(system_message_t));
    if (msg == NULL) {
        fprintf(stderr, "Failed to allocate message memory.\\n");
        exit(-1);
    }
    msg->sm = {NAME};
    wrapper = &msg->wrapper.{name};
    memcpy(wrapper, &e, sizeof(e));

    // Put the event on the queue, to be popped off later and handled
    // in order.
    success = enqueue(q, msg);
    if (!success) {
        fprintf(stderr, "Failed to enqueue message.\\n");
        exit(-1);
    }
}'''.replace('{name}', name).replace('{NAME}', name.upper()))


def gen_sm_id_t(names):
    print('typedef enum {')
    for name in names:
        print('    {},'.format(name.upper()))
    print('} sm_id_t;')

def gen_system_message_t(names):
    print('''
typedef struct {
    sm_id_t sm;
    union {''')
    for name in names:
        print('        {}_Event_Wrapper {};'.format(name, name))
    print('''    } wrapper;
} system_message_t;''')

def gen_flushEventQueue(names):
    print('''
void flushEventQueue(void) {
    // This function could be running in a parallel thread
    // concurrently with the rest of the system. The important thing
    // is that it pops messages off the queue and sends them to
    // xxx_Handle_Message.
    bool success;
    system_message_t *msg;

    while(size(q) > 0) {
        success = dequeue(q, (void **)&msg);
        if (!success) {
            fprintf(stderr, "Failed to dequeue element.\\n");
            exit(-1);
        }
        switch(msg->sm) {''')
    for name in names:
        print('''        case {NAME}:
            {name}_Handle_Message(msg->wrapper.{name});
            {name}_Free_Message(msg->wrapper.{name});
            break;'''.replace('{name}', name).replace('{NAME}', name.upper()))
    print('''        }
        free(msg);
    }
}''')

def generate(ident, names):
    print('''/* This file is generated by smudge.py. Do not edit it. */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "queue.h"
#include "{}_ext.h"'''.format(ident))
    gen_sm_id_t(names)
    gen_system_message_t(names)

    print('static queue_t *q;')

    gen_flushEventQueue(names)

    for name in names:
        gen_Send_Message(name)

    print('''
void SMUDGE_debug_print(const char *a1, const char *a2, const char *a3) {
    fprintf(stderr, a1, a2, a3);
}

void SMUDGE_free(const void *a1) {
    free((void *)a1);
}

void SMUDGE_panic(void) {
    exit(-1);
}

void SMUDGE_panic_print(const char *a1, const char *a2, const char *a3) {
    fprintf(stderr, a1, a2, a3);
}

int initEventQueue() {
    q = newq();
    if (q == NULL) {
        fprintf(stderr, "Failed to get a queue.\\n");
        return -1;
    }
    return 0;
}''')

def parse(filename):
    names = []
    with open(filename, 'r') as f:
        for line in f.readlines():
            line = line.strip()
            if line.endswith('{'):
                names.append(line[:-1].strip())

    return names

def main(script, filename):
    names = parse(filename)
    ident = filename.split('.')[0]

    generate(ident, names)

if __name__ == '__main__':
    import sys
    main(*sys.argv)
