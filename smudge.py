def gen_Send_Message(name):
    print('''
void {name}_Send_Message({name}_Event_Wrapper e) {
    bool success;
    system_message_t *msg;
    {name}_Event_Wrapper *wrapper;

    // The event wrapper is passed in on the stack, so we have to
    // allocate some memory that we can put in the message queue.
    msg = malloc(sizeof(system_message_t));
    if (msg == NULL) {
        DEBUG_println("Failed to allocate message memory.");
        return;
    }
    msg->sm = {NAME};
    wrapper = &msg->wrapper.{name};
    memcpy(wrapper, &e, sizeof(e));

    // Put the event on the queue, to be popped off later and handled
    // in order.
    success = enqueue(q, msg);
    if (!success) {
        DEBUG_println("Failed to enqueue message.");
        return;
    }
}'''.replace('{name}', name).replace('{NAME}', name.upper()))


def gen_sm_id_t(names):
    print('typedef enum {')
    for name in names:
        print('    {},'.format(name.upper()))
    print('} sm_id_t;')

def gen_system_message_t(names):
    print('''
typedef struct {
    sm_id_t sm;
    union {''')
    for name in names:
        print('        {}_Event_Wrapper {};'.format(name, name))
    print('''    } wrapper;
} system_message_t;''')

def gen_flushEventQueue(names):
    print('''
void flushEventQueue(void) {
    // This function could be running in a parallel thread
    // concurrently with the rest of the system. The important thing
    // is that it pops messages off the queue and sends them to
    // xxx_Handle_Message.
    bool success;
    system_message_t *msg;

    while(size(q) > 0) {
        success = dequeue(q, (void **)&msg);
        if (!success) {
            DEBUG_println("Failed to dequeue element.");
            return;
        }
        switch(msg->sm) {''')
    for name in names:
        print('''        case {NAME}:
            {name}_Handle_Message(msg->wrapper.{name});
            {name}_Free_Message(msg->wrapper.{name});
            break;'''.replace('{name}', name).replace('{NAME}', name.upper()))
    print('''        }
        free(msg);
    }
}''')

def generate(ident, names):
    print('''/* This file is generated by smudge.py. Do not edit it. */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "queue.h"
#include "multism.h"
#include "{}_ext.h"'''.format(ident))
    gen_sm_id_t(names)
    gen_system_message_t(names)

    print('static queue_t *q;')

    gen_flushEventQueue(names)

    for name in names:
        gen_Send_Message(name)

    print('''
int initEventQueue() {
    q = newq();
    if (q == NULL) {
        DEBUG_println("Failed to get a queue.");
        return -1;
    }
    return 0;
}''')

def parse(filename):
    names = []
    with open(filename, 'r') as f:
        for line in f.readlines():
            line = line.strip()
            if line.endswith('{'):
                names.append(line[:-1].strip())

    return names

def main(script, filename):
    names = parse(filename)
    ident = filename.split('.')[0]

    generate(ident, names)

if __name__ == '__main__':
    import sys
    main(*sys.argv)
